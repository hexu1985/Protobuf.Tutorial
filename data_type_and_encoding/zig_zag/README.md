### ZigZag编码

**ZigZag 编码解决了什么问题？**

先看下背景。假如 int32 类型的字段，其值为 -1 时，在内存中，因为使用了补码，所以存储为 ffffffff（4个字节），  
然后在 Varint 序列化的之前会强制转换成 int64 类型，这样其值会变为ffffffff ffffffff。  
转换成 Varint 编码时，会加上 Tag ，以及 msb ，总共是 10 个字节。我们希望其绝对值越小，编码之后使用越少的字节数表示，  
显然这里编码之后得到的结果和我们期望的结果相悖的，基于这样的原因，才引入了 ZigZag 编码，主要作用是对负数的压缩处理。

**ZigZag是怎么编码的？**
很简单，两个公式就搞定了，没有复杂的编码转换。

> zigzag32(n) = (n << 1) ^ (n >> 31)  //对于 sint32
> zigzag64(n) = (n << 1) ^ (n >> 63)  //对于 sint64

一般情况下我们认为，使用较多的是小整数（确切地说应该是绝对值小的整数），那么较小的整数应使用更少的字节数来编码，ZigZag 编码正是如此，如下表格：

| n           | 十六进制    | zigzag(n)   | varint(zigzag(n)) |
| ----------- | ----------- | ----------- | ----------------- |
| 0           | 00 00 00 00 | 00 00 00 00 | 00                |
| -1          | ff ff ff ff | 00 00 00 01 | 01                |
| 1           | 00 00 00 01 | 00 00 00 02 | 02                |
| -2          | ff ff ff fe | 00 00 00 03 | 03                |
| 2           | 00 00 00 02 | 00 00 00 04 | 04                |
| ...         | ...         | ...         | ...               |
| 2147483647  | 7f ff ff ff | ff ff ff fe | ff ff ff fe       |
| -2147483648 | 80 00 00 00 | ff ff ff ff | ff ff ff ff       |
